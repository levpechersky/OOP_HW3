'From Squeak5.1 of 5 September 2016 [latest update: #16549] on 9 December 2017 at 5:12:48 pm'!Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject commentStamp: 'LP 12/2/2017 12:14' prior: 0!IMPORTANT: 1. Every Interface must inherit from MyObject directly!!    2. Don't add any additional fields!!!!MyObject methodsFor: 'as yet unclassified' stamp: 'LP 12/9/2017 17:12'!foo: a bar:b baz: c| var1 |(a isKindOf: Integer) ifFalse: [ AssertionFailure signal: 'Type mismatch!! Argument 1 should be Integer' ].(c isKindOf: Number) ifFalse: [ AssertionFailure signal: 'Type mismatch!! Argument 3 should be Number' ].var1 := a + c." just a comment, nothing special "^ (var1 * var1)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'interfaces support' stamp: 'LP 12/2/2017 12:30'!ambiguities	! !!MyObject class methodsFor: 'interfaces support' stamp: 'LP 12/2/2017 12:29'!behavesLike	! !!MyObject class methodsFor: 'interfaces support' stamp: 'LP 12/2/2017 12:39'!isImplemented	"Error messages:"	AssertionFailure signal: '#CLASS is not an interface!!'.	! !!MyObject class methodsFor: 'interfaces support' stamp: 'LP 12/2/2017 12:29'!isInterface	! !!MyObject class methodsFor: 'private' stamp: 'LP 12/9/2017 14:21'!argumentsInMethod: aSourceCode^ (Parser new parse: aSourceCode class: MyObject) arguments collect: [:each | each name]! !!MyObject class methodsFor: 'private' stamp: 'LP 12/9/2017 15:52'!codeHasLocals: aSourceCode	| methodLines |	methodLines := aSourceCode findTokens: String cr.	^ (((methodLines size) > 1) and: [((methodLines at: 2) findString: '|') > 0 ]).		 ! !!MyObject class methodsFor: 'private' stamp: 'LP 12/9/2017 17:11'!getTypeCheckStringForArg: aArgIndex name: aArgName type: aTypeName	"Returns a string with source code for type check of argument"	"Note: no new line at the end"	| errorMessage |	(aTypeName isKindOf: UndefinedObject) 	ifTrue: [^'']	ifFalse: [		errorMessage :='''Type mismatch!! Argument ' , (aArgIndex asString) , ' should be ' , aTypeName , ''''.		^ '(' , aArgName , ' isKindOf: ' , aTypeName , ') ifFalse: [ AssertionFailure signal: ' , errorMessage , ' ].'.	].		 ! !!MyObject class methodsFor: 'subclass creation' stamp: 'LP 12/2/2017 12:28'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName	"create regular object, which isn't an interface or doesn't implement some interface directly"! !!MyObject class methodsFor: 'subclass creation' stamp: 'LP 12/2/2017 12:38'!subclass: aSubclassName isInterface: isInterface behavesLike:aCollection instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category:aCategoryName	" like 'Class' class 'subclass' method "	" Can use instVarNamed:put: for initialization of variables "		"Error messages (must be defined in that order):"	AssertionFailure signal: 'Interfaces must derive from MyObject!!'.	AssertionFailure signal: 'Interfaces can not have state!!'.	AssertionFailure signal: 'Classes can not derive from an interface!!'.	AssertionFailure signal: 'Can not behave like a non-interface!!'.! !!MyObject class methodsFor: 'compiling' stamp: 'LP 12/9/2017 16:12'!compile: aSourceCode where: anOrderedCollection	"Ordered collection contains type constraints, which arguments must satisfy (isKindOf), or nil's - no constraint"	"If aSourceCode doesn't receive any arg - anOrderedCollection will be empty"		"		Method logic:		Split source code into lines, take first one/two into new list.		Go over arguments, add a check line into new list for each param.		Take the rest of the method source lines, and compile.	"	| methodLines methodArgs injectStart typesIndex checkString checkedLines numLines outputSource |	methodLines := aSourceCode findTokens: String cr.		checkedLines := OrderedCollection new.	"Put selector and args:"	checkedLines addLast: (methodLines at: 1). 	 "Put locals:"	(MyObject codeHasLocals: aSourceCode) ifTrue: [checkedLines addLast: (methodLines at: 2)].		methodArgs := MyObject argumentsInMethod: aSourceCode.	(methodArgs size == anOrderedCollection size)		ifFalse: [AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'].			"Add type-check strings to list of source code."	typesIndex := 1.	methodArgs do: [:methodArg | 	checkString := MyObject getTypeCheckStringForArg: typesIndex name: methodArg type: (anOrderedCollection at: typesIndex).		checkedLines addLast: (checkString).		typesIndex := typesIndex + 1.	].	"Add the rest of the lines to the list of all lines."	(MyObject codeHasLocals: aSourceCode) ifTrue: [injectStart:=3] ifFalse: [injectStart:=2].	numLines := methodLines size.	injectStart to: numLines do:		[: index | checkedLines addLast: (methodLines at: index)].		"Finally, create final string"	outputSource := ''.	checkedLines do:  [:line | outputSource := outputSource , line, String cr.].		^outputSource	"TODO: need to compile it instead of returning a string"	! !