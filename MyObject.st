'From Squeak5.1 of 5 September 2016 [latest update: #16549] on 10 December 2017 at 8:23:58 pm'!Object subclass: #MyObject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3'!!MyObject commentStamp: 'LP 12/2/2017 12:14' prior: 0!IMPORTANT: 1. Every Interface must inherit from MyObject directly!!    2. Don't add any additional fields!!!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MyObject class	instanceVariableNames: 'behavesLike isInterface'!!MyObject class methodsFor: 'interfaces support' stamp: 'LP 12/2/2017 12:30'!ambiguities	! !!MyObject class methodsFor: 'interfaces support' stamp: 'LP 12/10/2017 17:09'!behavesLike	^behavesLike.	! !!MyObject class methodsFor: 'interfaces support' stamp: 'LP 12/2/2017 12:39'!isImplemented	"Error messages:"	AssertionFailure signal: '#CLASS is not an interface!!'.	! !!MyObject class methodsFor: 'interfaces support' stamp: 'LP 12/9/2017 19:59'!isInterface	^isInterface.	! !!MyObject class methodsFor: 'private' stamp: 'LP 12/9/2017 14:21'!argumentsInMethod: aSourceCode^ (Parser new parse: aSourceCode class: MyObject) arguments collect: [:each | each name]! !!MyObject class methodsFor: 'private' stamp: 'LP 12/9/2017 15:52'!codeHasLocals: aSourceCode	| methodLines |	methodLines := aSourceCode findTokens: String cr.	^ (((methodLines size) > 1) and: [((methodLines at: 2) findString: '|') > 0 ]).		 ! !!MyObject class methodsFor: 'private' stamp: 'LP 12/9/2017 17:11'!getTypeCheckStringForArg: aArgIndex name: aArgName type: aTypeName	"Returns a string with source code for type check of argument"	"Note: no new line at the end"	| errorMessage |	(aTypeName isKindOf: UndefinedObject) 	ifTrue: [^'']	ifFalse: [		errorMessage :='''Type mismatch!! Argument ' , (aArgIndex asString) , ' should be ' , aTypeName , ''''.		^ '(' , aArgName , ' isKindOf: ' , aTypeName , ') ifFalse: [ AssertionFailure signal: ' , errorMessage , ' ].'.	].		 ! !!MyObject class methodsFor: 'private' stamp: 'LP 12/10/2017 17:53'!legalInterfaceMethod: aSourceCode	^((MyObject methodIsEmpty: aSourceCode) or: [MyObject methodIsDefault: aSourceCode ]).				 ! !!MyObject class methodsFor: 'private' stamp: 'LP 12/10/2017 18:02'!methodIsDefault: aSourceCode	| linesOfCode prefix selectorLine |	prefix := 'default'.		linesOfCode := aSourceCode findTokens: String cr.	linesOfCode isEmpty ifTrue: [ ^false ].	selectorLine := linesOfCode at: 1. 			^(selectorLine size >= prefix size) and: [ selectorLine copyFrom: 1 to: (prefix size) = prefix ].				 ! !!MyObject class methodsFor: 'private' stamp: 'LP 12/10/2017 18:04'!methodIsEmpty: aSourceCode	| linesOfCode |	linesOfCode := aSourceCode findTokens: String cr.	^ linesOfCode size = 1.	"TODO: is it possible for empty method to have some empty lines?"		 ! !!MyObject class methodsFor: 'subclass creation' stamp: 'LP 12/10/2017 17:17'!subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName	| newClass | 		"Errors:"	(self isInterface) ifTrue: [		AssertionFailure signal: 'Classes can not derive from an interface!!'.	].		"It's important to create subclass using 'super', otherwise it will cause infinite loop"	newClass := super subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName.		newClass instVarNamed: 'isInterface' put: false.	newClass instVarNamed: 'behavesLike' put: (OrderedCollection new).			^newClass	! !!MyObject class methodsFor: 'subclass creation' stamp: 'LP 12/10/2017 16:55'!subclass: aSubclassName isInterface: isInterface behavesLike:aCollection instanceVariableNames: instVarNames classVariableNames:classVarNames poolDictionaries: poolDictionaries category:aCategoryName	| newClass | 		"Errors:"	(isInterface and: [ (self isMemberOf: MyObject class) not ]) ifTrue: [		AssertionFailure signal: 'Interfaces must derive from MyObject!!'.	].	(isInterface and: [ instVarNames isEmpty not ]) ifTrue: [		AssertionFailure signal: 'Interfaces can not have state!!'.	].	(self isInterface) ifTrue: [		AssertionFailure signal: 'Classes can not derive from an interface!!'.	].	"Check if there's any element x in aCollection s.t. x isn't an interface"	((aCollection reject:  [:x | x isInterface]) isEmpty) ifFalse: [		AssertionFailure signal: 'Can not behave like a non-interface!!'.	].		newClass := self subclass: aSubclassName instanceVariableNames: instVarNamesclassVariableNames: classVarNames poolDictionaries: poolDictionariescategory: aCategoryName.		newClass instVarNamed: 'isInterface' put: isInterface.	newClass instVarNamed: 'behavesLike' put: aCollection.		^newClass	! !!MyObject class methodsFor: 'compiling' stamp: 'LP 12/10/2017 17:55'!compile: aSourceCode 		(self isInterface and: [(MyObject legalInterfaceMethod: aSourceCode) not ]) ifTrue: [		AssertionFailure signal: 'Interfaces are not allowed to have non default methods that define behavior!!'	].			super compile: aSourceCode.	! !!MyObject class methodsFor: 'compiling' stamp: 'LP 12/10/2017 16:43'!compile: aSourceCode where: anOrderedCollection	"Ordered collection contains type constraints, which arguments must satisfy (isKindOf), or nil's - no constraint"	"If aSourceCode doesn't receive any arg - anOrderedCollection will be empty"		"		Method logic:		Split source code into lines, take first one/two into new list.		Go over arguments, add a check line into new list for each param.		Take the rest of the method source lines, and compile.	"	| methodLines methodArgs injectStart typesIndex checkString checkedLines numLines outputSource |	methodLines := aSourceCode findTokens: String cr.		checkedLines := OrderedCollection new.	"Put selector and args:"	checkedLines addLast: (methodLines at: 1). 	 "Put locals:"	(MyObject codeHasLocals: aSourceCode) ifTrue: [checkedLines addLast: (methodLines at: 2)].		methodArgs := MyObject argumentsInMethod: aSourceCode.	(methodArgs size == anOrderedCollection size)		ifFalse: [AssertionFailure signal: 'Can not compile method, number of arguments is not equal to the number of constraints!!'].			"Add type-check strings to list of source code."	typesIndex := 1.	methodArgs do: [:methodArg | 	checkString := MyObject getTypeCheckStringForArg: typesIndex name: methodArg type: (anOrderedCollection at: typesIndex).		checkedLines addLast: (checkString).		typesIndex := typesIndex + 1.	].	"Add the rest of the lines to the list of all lines."	(MyObject codeHasLocals: aSourceCode) ifTrue: [injectStart:=3] ifFalse: [injectStart:=2].	numLines := methodLines size.	injectStart to: numLines do:		[: index | checkedLines addLast: (methodLines at: index)].		"Create final string:"	outputSource := ''.	checkedLines do:  [:line | outputSource := outputSource , line, String cr.].		"Add new method to receiver class:"	self compile: outputSource.		^outputSource	! !