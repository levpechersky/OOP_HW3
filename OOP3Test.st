'From Squeak5.1 of 5 September 2016 [latest update: #16549] on 11 December 2017 at 8:11:43 pm'!TestCase subclass: #OOP3Test	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3-Tests'!!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/10/2017 19:08'!expectErrorFrom: aBlock withErrMessage: aMessage	self should: aBlock raise: AssertionFailure  withExceptionDo:  [:e | self assert: (e messageText = aMessage) ]. 		! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 16:44'!setUpMyObject instVarNamed: 'isInterface' put: false.MyObject instVarNamed: 'behavesLike' put: {}."Add here any additional identifier, you are going to use for class/interface name:"(Smalltalk hasClassNamed: #A) ifTrue: [Smalltalk removeClassNamed: #A].(Smalltalk hasClassNamed: #B) ifTrue: [Smalltalk removeClassNamed: #B].(Smalltalk hasClassNamed: #C) ifTrue: [Smalltalk removeClassNamed: #C].(Smalltalk hasClassNamed: #D) ifTrue: [Smalltalk removeClassNamed: #D].(Smalltalk hasClassNamed: #IA) ifTrue: [Smalltalk removeClassNamed: #IA].(Smalltalk hasClassNamed: #IB) ifTrue: [Smalltalk removeClassNamed: #IB].(Smalltalk hasClassNamed: #IC) ifTrue: [Smalltalk removeClassNamed: #IC].(Smalltalk hasClassNamed: #ID) ifTrue: [Smalltalk removeClassNamed: #ID].! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 20:09'!testAmbiguitiesself assert: false description: 'TODO: add tests'.	! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 19:04'!testAmbiguitiesBasic| tmp |"1. Simple case: 2 interfaces, implemented directly, no default methods"MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.IA compile: 'ambiguousFoo'.IA compile: 'ambiguousBar'.IA compile: 'ambiguousBaz'.IA compile: 'foo'.IA compile: 'bar'.MyObject subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.IB compile: 'ambiguousFoo'.IB compile: 'ambiguousBar'.IB compile: 'ambiguousBaz'.IB compile: 'baz'.IB compile: 'example'.MyObject subclass: #A isInterface: false behavesLike: {IA . IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.tmp := A ambiguities.	self assert: (A ambiguities asOrderedCollection = (#(#ambiguousBar #ambiguousBaz #ambiguousFoo) asOrderedCollection))."TODO: add more tests"	! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 16:56'!testBehavesLikeRecursive| newClass tmp |"1. Every interface behaves like itself:"newClass := MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.self assert: (IA behavesLike = {IA} asSet)."2. Class behaves like an interface IX, if that class was defined with behavesLike {IX}"newClass := MyObject subclass: #A isInterface: false behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.self assert: (A behavesLike = {IA} asSet)."3. Class behaves like IX, if it behaves like IY, which behaves like IX"newClass := MyObject subclass: #IB isInterface: true behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.newClass := MyObject subclass: #B isInterface: false behavesLike: {IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.tmp := B behavesLike.self assert: (B behavesLike = {IA . IB} asSet)."4. Class behaves like IX, if it is subclass of Y, which behaves like IX""Simple case: D is a child of A, which behaves like IA"A subclass: #D isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.tmp := D behavesLike.self assert: (D behavesLike = {IA} asSet)."More compicated case: C is a child of B. B behaves like IB, which behaves like IA"B subclass: #C isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.tmp := C behavesLike.self assert: (C behavesLike = {IA . IB} asSet)."5. Check return value:"self assert: (IA behavesLike isKindOf: Set).self assert: (A  behavesLike isKindOf: Set).self assert: (C  behavesLike isKindOf: Set).! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 20:02'!testCompileInterfaceMethods| defaultMethod emptyMethod nonEmptyMethod |MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.nonEmptyMethod := 'illegalFoo: aArg| localVar | ^ localVar = aArg'.self expectErrorFrom: [ IA compile: nonEmptyMethod. ] withErrMessage: 'Interfaces are not allowed to have non default methods that define behavior!!'.emptyMethod := 'emptyBar'. IA compile: emptyMethod.self assert: (IA methodDict size = 1)." Note a new line at the end of method. Should be OK, I think: "emptyMethod := 'emptyFoo: arg0  bar: arg1'. IA compile: emptyMethod.self assert: (IA methodDict size = 2).defaultMethod := 'defaultFoo: aNumber| someLocalVar | someLocalVar := 300." a comment "^aNumber + someLocalVar. '.IA compile: defaultMethod. self assert: (IA methodDict size = 3)." But we still can't check compiled method until part C is implemented :( "! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/10/2017 19:44'!testCompileWhere| a result message | MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Initial state:"self assert: (A methodDict isEmpty).self assert: (A isInterface = false).self assert: (A behavesLike isEmpty)."compiling the new way: number of arguments !!= number of constraints"message := 'Can not compile method, number of arguments is not equal to the number of constraints!!'.self expectErrorFrom: [ A compile: 'foo: a' where: {} ] withErrMessage: message.self expectErrorFrom: [ A compile: 'foo: a' where: #(Integer String nil) ] withErrMessage: message.self expectErrorFrom: [ A compile: 'foo: a bar: b' where: #(nil) ] withErrMessage: message.self assert: (A methodDict isEmpty).   "Error cases shouldn't add methods"a := A new."compiling the old way"A compile:'mOldNoArgs^42'.self assert: (A methodDict size = 1).result := a mOldNoArgs.self assert: (result = 42)."compiling the new way:"A compile:'mNewInteger: a^a' where: #(Integer).self assert: (A methodDict size = 2).message := 'Type mismatch!! Argument 1 should be Integer'.self expectErrorFrom: [ a mNewInteger: 'NaN' ] withErrMessage: message.self expectErrorFrom: [ a mNewInteger: 0.5   ] withErrMessage: message.result := a mNewInteger: 1.self assert: (result = 1)."compiling the new way: with locals, no args"A compile:'mNewNoArgs| localVar |localVar := 42.^localVar' where: {}.result := a mNewNoArgs.self assert: (result = 42)."compiling the new way: multiple args, with nil constraint"A compile:'mNewManyArgsWithNil: a arg1: b arg2: c| localVar |localVar := 2.^localVar * a * b * c' where: #(Integer Number nil).self expectErrorFrom: [ a mNewManyArgsWithNil: 0.1 arg1: 4.0    arg2: 5 ] withErrMessage: 'Type mismatch!! Argument 1 should be Integer'.self expectErrorFrom: [ a mNewManyArgsWithNil: 3    arg1: 'NaN' arg2: 5 ] withErrMessage: 'Type mismatch!! Argument 2 should be Number'.result := a mNewManyArgsWithNil: 3 arg1: 4.0 arg2: 5.      self assert: (result = (2*3*4.0*5)).result := a mNewManyArgsWithNil: 3 arg1: 4.0 arg2: 10.0.      self assert: (result = (2*3*4.0*10.0)).! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 20:05'!testInterfaceCantHaveInstanceMyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.	self expectErrorFrom: [ 	IA new ] withErrMessage: 'Interfaces can not be instantiated!!'.! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 20:07'!testIsImplementedNoMethods| newClass |" 2 interfaces: IB extends IA "newClass := MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.newClass := MyObject subclass: #IB isInterface: true behavesLike: {IA} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."If interface IB behaves like IA - IA still isn't implemented"self assert: (IA isImplemented = false).newClass := MyObject subclass: #A isInterface: false behavesLike: {IB} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."IB implemented directly by A"self assert: (IB isImplemented = true)."IA is implemented by A through IB"self assert: (IA isImplemented = true)."You can't send 'isImplemented' to a regular class:"self expectErrorFrom: [ A isImplemented ] withErrMessage: 'A is not an interface!!'.! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 20:10'!testIsImplementedWithMethodsself assert: false description: 'TODO: add tests'.! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 20:03'!testMyObjectFieldsself assert: (MyObject class instVarNames size = 2).self assert: (MyObject class instVarNames includes: 'isInterface').self assert: (MyObject class instVarNames includes: 'behavesLike').	! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 20:04'!testSubclassCreationBadPathMyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.	"error 2.1"self expectErrorFrom: [	A subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Interfaces must derive from MyObject!!'."error 2.2"self expectErrorFrom: [	MyObject subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: 'foo bar baz' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Interfaces can not have state!!'."error 2.3"self expectErrorFrom: [	IA subclass: #B isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Classes can not derive from an interface!!'."error 2.4"self expectErrorFrom: [	MyObject subclass: #B isInterface: false behavesLike: {A} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Can not behave like a non-interface!!'."Now we are testing errors precedence:""2.1 before 2.2"self expectErrorFrom: [	A subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: 'more variables to the god of instanceVariables' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Interfaces must derive from MyObject!!'."2.2 before 2.4 (because 2.2 and 2.3 can't happen at the same time, and same for 2.1 and 2.3)"self expectErrorFrom: [	MyObject subclass: #IB isInterface: true behavesLike: {A} instanceVariableNames: 'foo bar baz' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Interfaces can not have state!!'."2.3 before 2.4"self expectErrorFrom: [	IA subclass: #B isInterface: false behavesLike: {A} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Classes can not derive from an interface!!'.! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 20:05'!testSubclassCreationNoMethods| newClass |"Create old-style class:"newClass := MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (A class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: A)."Check fields:"self assert: (A isInterface = false)."Create new-style class:"newClass := MyObject subclass: #B isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (B class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: B)."Check fields:"self assert: (B isInterface = false)."Create an interface:"newClass := MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (IA class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: IA)."Check fields:"self assert: (IA isInterface = true)."Create new-style class, implementing an interface:"MyObject subclass: #C isInterface: false behavesLike: {IA} instanceVariableNames: 'x y z' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Check fields and instance variables:"self assert: (C isInterface = false).self assert: ((C instVarNames) includes: 'x').self assert: ((C instVarNames) includes: 'y').self assert: ((C instVarNames) includes: 'z').! !