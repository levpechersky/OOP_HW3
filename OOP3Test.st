'From Squeak5.1 of 5 September 2016 [latest update: #16549] on 11 December 2017 at 12:04:16 pm'!TestCase subclass: #OOP3Test	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'OOP3Tests'!!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/10/2017 19:08'!expectErrorFrom: aBlock withErrMessage: aMessage	self should: aBlock raise: AssertionFailure  withExceptionDo:  [:e | self assert: (e messageText = aMessage) ]. 		! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/10/2017 17:19'!setUpMyObject instVarNamed: 'isInterface' put: false.MyObject instVarNamed: 'behavesLike' put: {}."Add here any additional identifier, you are going to use for class/interface name:"(Smalltalk hasClassNamed: #A) ifTrue: [Smalltalk removeClassNamed: #A].(Smalltalk hasClassNamed: #B) ifTrue: [Smalltalk removeClassNamed: #B].(Smalltalk hasClassNamed: #C) ifTrue: [Smalltalk removeClassNamed: #C].(Smalltalk hasClassNamed: #IA) ifTrue: [Smalltalk removeClassNamed: #IA].(Smalltalk hasClassNamed: #IB) ifTrue: [Smalltalk removeClassNamed: #IB].! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/10/2017 19:44'!testCompileWhere| a result message | MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Initial state:"self assert: (A methodDict isEmpty).self assert: (A isInterface = false).self assert: (A behavesLike isEmpty)."compiling the new way: number of arguments !!= number of constraints"message := 'Can not compile method, number of arguments is not equal to the number of constraints!!'.self expectErrorFrom: [ A compile: 'foo: a' where: {} ] withErrMessage: message.self expectErrorFrom: [ A compile: 'foo: a' where: #(Integer String nil) ] withErrMessage: message.self expectErrorFrom: [ A compile: 'foo: a bar: b' where: #(nil) ] withErrMessage: message.self assert: (A methodDict isEmpty).   "Error cases shouldn't add methods"a := A new."compiling the old way"A compile:'mOldNoArgs^42'.self assert: (A methodDict size = 1).result := a mOldNoArgs.self assert: (result = 42)."compiling the new way:"A compile:'mNewInteger: a^a' where: #(Integer).self assert: (A methodDict size = 2).message := 'Type mismatch!! Argument 1 should be Integer'.self expectErrorFrom: [ a mNewInteger: 'NaN' ] withErrMessage: message.self expectErrorFrom: [ a mNewInteger: 0.5   ] withErrMessage: message.result := a mNewInteger: 1.self assert: (result = 1)."compiling the new way: with locals, no args"A compile:'mNewNoArgs| localVar |localVar := 42.^localVar' where: {}.result := a mNewNoArgs.self assert: (result = 42)."compiling the new way: multiple args, with nil constraint"A compile:'mNewManyArgsWithNil: a arg1: b arg2: c| localVar |localVar := 2.^localVar * a * b * c' where: #(Integer Number nil).self expectErrorFrom: [ a mNewManyArgsWithNil: 0.1 arg1: 4.0    arg2: 5 ] withErrMessage: 'Type mismatch!! Argument 1 should be Integer'.self expectErrorFrom: [ a mNewManyArgsWithNil: 3    arg1: 'NaN' arg2: 5 ] withErrMessage: 'Type mismatch!! Argument 2 should be Number'.result := a mNewManyArgsWithNil: 3 arg1: 4.0 arg2: 5.      self assert: (result = (2*3*4.0*5)).result := a mNewManyArgsWithNil: 3 arg1: 4.0 arg2: 10.0.      self assert: (result = (2*3*4.0*10.0)).! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/10/2017 19:36'!testInterfaceCreationBadPathMyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'.	"error 2.1"self expectErrorFrom: [	A subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Interfaces must derive from MyObject!!'."error 2.2"self expectErrorFrom: [	MyObject subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: 'foo bar baz' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Interfaces can not have state!!'."error 2.3"self expectErrorFrom: [	IA subclass: #B isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Classes can not derive from an interface!!'."error 2.4"self expectErrorFrom: [	MyObject subclass: #B isInterface: false behavesLike: {A} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Can not behave like a non-interface!!'."Now we are testing errors precedence:""2.1 before 2.2"self expectErrorFrom: [	A subclass: #IB isInterface: true behavesLike: {} instanceVariableNames: 'more variables to the god of instanceVariables' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Interfaces must derive from MyObject!!'."2.2 before 2.4 (because 2.2 and 2.3 can't happen at the same time, and same for 2.1 and 2.3)"self expectErrorFrom: [	MyObject subclass: #IB isInterface: true behavesLike: {A} instanceVariableNames: 'foo bar baz' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Interfaces can not have state!!'."2.3 before 2.4"self expectErrorFrom: [	IA subclass: #B isInterface: false behavesLike: {A} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'] withErrMessage: 'Classes can not derive from an interface!!'.! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/10/2017 20:23'!testInvariantsself assert: ((MyObject class instVarNames) size = 2).self assert: ((MyObject class instVarNames) includes: 'isInterface').self assert: ((MyObject class instVarNames) includes: 'behavesLike').	! !!OOP3Test methodsFor: 'as yet unclassified' stamp: 'LP 12/11/2017 11:58'!testSubclassCreation| newClass |"Create old-style class:"newClass := MyObject subclass: #A instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (A class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: A)."Check fields:"self assert: (A isInterface = false).self assert: (A behavesLike isEmpty)."Create new-style class:"newClass := MyObject subclass: #B isInterface: false behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (B class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: B)."Check fields:"self assert: (B isInterface = false).self assert: (B behavesLike isEmpty)."Create an interface:"newClass := MyObject subclass: #IA isInterface: true behavesLike: {} instanceVariableNames: '' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Check return value:"self assert: (newClass isMemberOf: (IA class)). "Check inheritance correctness:"self assert: (newClass superclass = MyObject).self assert: ((MyObject subclasses) includes: IA)."Check fields:"self assert: (IA isInterface = true).self assert: (IA behavesLike = ({IA} asSet)). "interface behaves like itself""Create new-style class, implementing an interface:"MyObject subclass: #C isInterface: false behavesLike: {IA} instanceVariableNames: 'x y z' classVariableNames: '' poolDictionaries: ''	category: 'OOP3'."Check fields and instance variables:"self assert: (C isInterface = false).self assert: (C behavesLike = ({IA} asSet)).self assert: ((C instVarNames) includes: 'x').self assert: ((C instVarNames) includes: 'y').self assert: ((C instVarNames) includes: 'z').! !